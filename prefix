#include <iostream>
using namespace std;

#define MAX 100

// Stack for operators
char stack[MAX];
int top = -1;

void push(char c) {
    if (top == MAX - 1) {
        cout << "Stack overflow" << endl;
    } else {
        stack[++top] = c;
    }
}

char pop() {
    if (top == -1) {
        return '\0'; // Return null character if stack is empty
    } else {
        return stack[top--];
    }
}

char peek() {
    if (top == -1) {
        return '\0'; // Return null character if stack is empty
    } else {
        return stack[top];
    }
}

bool isEmpty() {
    return top == -1;
}

int precedence(char c) {
    switch (c) {
        case '^': return 4;
        case '*': case '/': return 3;
        case '+': case '-': return 2;
        default: return 0;
    }
}

void reverse(char* str) {
    int start = 0;
    int end = 0;
    
    // Find length of string
    while (str[end] != '\0') {
        end++;
    }
    end--; // Adjust for zero-based indexing

    // Reverse the string
    while (start < end) {
        char temp = str[start];
        str[start] = str[end];
        str[end] = temp;
        start++;
        end--;
    }
}

void replaceParentheses(char* str) {
    int i = 0;
    while (str[i] != '\0') {
        if (str[i] == '(') {
            str[i] = ')';
        } else if (str[i] == ')') {
            str[i] = '(';
        }
        i++;
    }
}

void infixToPostfix(const char* infix, char* postfix) {
    int j = 0;
    int i = 0;
    
    while (infix[i] != '\0') {
        char symb = infix[i];
        
        if (symb >= 'a' && symb <= 'z' || symb >= 'A' && symb <= 'Z') {
            postfix[j++] = symb;
        } else if (symb == '(') {
            push(symb);
        } else if (symb == ')') {
            while (!isEmpty() && peek() != '(') {
                postfix[j++] = pop();
            }
            pop(); // Remove '(' from stack
        } else { // Operator
            while (!isEmpty() && precedence(peek()) >= precedence(symb)) {
                postfix[j++] = pop();
            }
            push(symb);
        }
        i++;
    }
    
    while (!isEmpty()) {
        postfix[j++] = pop();
    }
    postfix[j] = '\0'; // Null-terminate the postfix expression
}

void infixToPrefix(const char* infix, char* prefix) {
    char reversedInfix[MAX];
    char postfix[MAX];
    
    // Copy and reverse the infix expression
    int length = 0;
    while (infix[length] != '\0') {
        length++;
    }
    
    for (int i = 0; i < length; i++) {
        reversedInfix[i] = infix[length - i - 1];
    }
    reversedInfix[length] = '\0';
    
    // Replace parentheses in reversed infix expression
    replaceParentheses(reversedInfix);
    
    // Convert reversed infix to postfix
    infixToPostfix(reversedInfix, postfix);
    
    // Reverse the postfix expression to get prefix
    reverse(postfix);
    
    // Copy result to prefix
    int j = 0;
    while (postfix[j] != '\0') {
        prefix[j] = postfix[j];
        j++;
    }
    prefix[j] = '\0'; // Null-terminate the prefix expression
}

int main() {
    char infix[MAX], prefix[MAX];
    
    cout << "Enter infix expression: ";
    cin >> infix;
    
    infixToPrefix(infix, prefix);
    
    cout << "Prefix expression: " << prefix << endl;
    
    return 0;
}
